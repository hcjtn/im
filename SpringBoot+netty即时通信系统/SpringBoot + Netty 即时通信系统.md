# SpringBoot + Netty 即时通信系统



## 打造即时通信系统

[即时消息：一个完整的IM系统是怎样的](https://blog.csdn.net/zhizhengguan/article/details/121596874)

需要接入层去维护我们客户端的长连接和消息收发，同时 运输层选择TCP协议，和选择合理的用户层协议，还需要做好用户session的维护，因为Http是无状态的服务，逻辑层需要处理消息收发的核心逻辑，配合接入层和存储层，做到消息真正的不丢失，存储层需要选择合适的关系形数据库，实现海量的数据的存储。







IM即时通信系统可以参考腾讯云的IM

[即时通信 IM 生成 UserSig-服务端 API-文档中心-腾讯云 (tencent.com)](https://cloud.tencent.com/document/product/269/32688)

[「群组」和「聊天室」有什么区别？_im 聊天室和群聊区别](https://blog.csdn.net/qq_45455361/article/details/124791685#:~:text=所有群成员可以收到群中的消息，可以在群中发送消息。,群成员离线时可以收到推送消息。 群组分为公开群和私有群，公开群可以被搜索到，非群成员可以加入；私有群不能搜索到，需要群主或群管理员添加非群成员进入。)







通知 实现的是数据的多端同步 同一用户的多个数据端同步

+ 本项目中，是通过rabbitmq进行消息传递管理，所以在通知操作中是将消息传递到mq中进行传递



回调 实现的是 即时通信 IM 后台会在某一事件发生之前或者之后，向 App 的后台服务器发送请求，App 后台可以据此进行必要的数据同步，或者干预事件的后续处理流程               







多netty情况下，执行channel的消息传递

在多个netty的情况下，channel正常情况下是无法跨netty传递的，netty1是无法找到netty2的channel，有三种方法解决

+ 广播发送需要的获取的channel，缺点在请求访问过多的情况下 会发生广播风暴
+ 哈希取余算法，缺点，如果有扩容或者缩容状况发生，经过取余极有可能无法找到对应netty 需要停机进行重新分配
+ 构建路由层，将每个channel对应的ip+port存储到路由层当中去，每次请求经过路由层查询，寻找到对应的服务器
  + 在本项目中 使用redis代替 将数据以key-value 的形式存储起来

![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2023-12-19_10-59-21.png)





多端登录下，执行踢人下线  采用广播的模式

原因：多端下线的情况出现次数少，广播风暴的情况几乎不会出现

​			而使用一致性hash算法（固定某一个用户的所有设备只会登录在某一台服务器上面），服务器集群的扩容缩容会导致可无法寻找到对应的用户channel，并且可能出现连接分布不均的可能

​			使用路由层的话，就会有点笨拙，需要遍历该用户下所有的channel，在所有的netty服务器下寻找，一一比对是否机型重合，重合就踢下线，效率较慢

> 我们在路由层存储的情况是，将用户和netty服务器联系起来，没有标识用户所使用的机器类型 (是安卓 ios还win之类的)





我们的im支持多平台登录





九章 这一个章节我们需要来着手完成单聊和群聊的消息收发。我们将通过逻辑层对消息做处理，处理之后再把消息真正投递给用户。W会实现历史消息的持久化。 

+ 读扩散/ 写扩散







 单聊消息的分发逻辑

![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-06_20-18-33.png)

群聊的分发逻辑

![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-07_14-47-51.png)







消息的持久化

写扩散

![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-07_16-02-49.png)

读扩散

![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-07_16-02-59.png)

读扩散减轻了写的压力 但是却增加了在mysql中读的压力

> 在写的时候，只需要写入一次，在读取的时候 查询复杂    没有办法构建索引
>
> ![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-07_16-19-04.png)
>
> 写扩散数据查询
>
> ![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-07_16-22-50.png)



单聊是 p2p 进行写扩散 对数据库服务器的压力不大 

如果是群聊 采用写扩散 群聊人数很多(有1w人) 一个人发一条消息 需要复制一万次到每个群成员当中去 所以需要采用读扩散







所以单聊使用写扩散  群聊使用读扩散

> 如果群聊采用写扩散 需要将消息头和消息体分开来 极大的减轻服务器的压力
>
> ![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-07_16-36-01.png)

分布式消息主键

+ 需要保证主键的唯一
  + 如何保证


常见id生成策略

+  uuid
+ 时间戳
+ 雪花算法 开源的分布式id算法  
+ 自定义算法





[MyBatis-Plus自定义DefaultSqlInjector，添加自定义通用方法（replace、insertIgnore、insertIgnoreBatch](https://blog.csdn.net/QIU176161650/article/details/117248797)





#### 十章 重要！！！

该项目需要实现

+ 实时性、 

  + 多线程解决解决串行问题 
  + 消息检验前置 在tcp服务器中进行校验
  + 持久化解耦 异步持久化聊天记录

+ 有序性(保证消息的顺序一致，减少歧义)，

  + 使用绝对递增的序列号解决问题

+ 可靠性(保证消息的不丢失)，

  + 服务端给发送方ack
  + 接收方给服务端ack
  + 发送方定时重传

+ 幂等性(发送方发送一条消息确保接收方只能接受到一条消息 )

  + 服务端去重

  + 接收端去重

  + > 当发送端二次重发消息时，可能导致接收端会出现两次相同的消息   实现了可靠性幂等性就无法保证
    >
    > 例如：当发送端没有及时接收到来自接收端返回的ack，会再次发送一条message ，这时候接收端接收到了第一次的message，和第二次message
    >
    > 这时候需要进行去重操作
    >
    > 服务端去重：只会对第一次传递过来的message进行持久化，之后传递过来的message直接发送给接收端 实现技术：采用messageKey 会利用redis增加操作的原子性将messageKey存储一定的时间，通过判断messagekey来确定对应的message时候为第一次发送
    >
    > 接收端去重：相同messageKey的消息只会显示一次，来保证幂等性




**可靠性**

tcp本身就是可靠的消息传递，包含实时性 可靠性 幂等性，那么为什么还要实现上面的特性

> 数据的传输过程
>
> ![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-13_09-50-38.png)

TCP只能保证到传输层的数据是不乱的，那么应用层的情况是无法保证的 所以需要在应用层实现消息的可靠性





A send to B

**b在线**

![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-13_09-59-32.png)

A在发送消息后会确定服务器是否接收到该消息 如果服务器接收到消息会返回ack，如果没有返回ack包，A回持续重传，服务器接收到A传递过来的消息后，会将消息传递给B，B也回返回ack包传递给服务器，服务器会将b传递过来的ack包发送给A A发送结束，A如果没有接收到Ack包会再次重传。

> A接收到2个ack以后才会停止重发



**b不在线**

![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-13_10-07-23.png)

b不在线的话会，服务器会直接返回 receive ack serversend 包







**消息已读策略的实现**

商务类的即时通信系统需要实现已读功能

而生活类的app则不需要实现该功能，会暴露用户的隐私

如果是写扩散，在数据库中消息索引有很多份，我们可以给消息索引加上是否已读的字段，将消息是否已读的字段上报给服务器，服务器根据该字段修改对应用户的消息读取字段。

如果是读扩散，用一个值来确定群成员读到那条消息，这个值以前的消息都算已读，有两个地方可以添加这个值

+ 第一个 是我们的群成员表，表中添加一个字段：已读取的最后一条消息的sequence, 服务端将最后一条消息的sequence设置到我们的群成员表的对应字段上面

+ 第二个 是将这个值与会话绑定（例如群内有五百个用户 就有500个会话）使用会话来表示聊天框，不同的会话有不同的聊天框，不同的聊天框有不同的sequence 

  给系统构建一个会话的概念，当已读到某一个消息的sequence的时候，将修改对应会话的已读取消息的sequence





离线消息的存储介质

+ mysql 和历史消息相似 离线消息涉及到删除 如果是软删除，和历史消息相同   如果是硬删除 涉及到行锁 使得效率降低 
+ redis 内存数据库 离线消息不会太大 但基数很多 很适合

怎么存 选择存储结构

+  zset





#### 十一章

为什么第一次登陆这么慢？

第一次登陆要进行客户端和服务端的同步

+ 需要同步的数据：会话 好友 群聊

不知本地的数据是否是最新的数据 每次拉取都是全量拉取

优化

1. 延迟拉取/按需拉取 只有在用到部分数据的时候才去拉取对应的数据。 

   + 有点 进入应用的时间更快
   + 缺点 只是将时间分开处理 在使用过程中需要延迟等待，但im系统中数据(指好友和群组数据)变化频率不快

2. 增加数据序列号(或者叫版本号)

   + ![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-15_16-40-22.png)

   + 摆脱了每次都需要全量拉取的问题，，大大降低了数据同步的时间和数据同步的量。但大部分情况下，服务端和客户端之间的版本 号是相同的



3.  服务端seq变更好额外写入用户的seq的值

   + ![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-15_16-44-47.png)

     对比不同字段的seq值 当不相同时 客户端获取服务端的更新后的数据





增量拉取流程：

1. 在用户登陆的时候判断seq是否相同 相同只进行离线message的拉取 如果不同 则是 先进行好友、群组、会话的增量拉取 在进行离线数据message的拉取







#### 十二章  用户的在线状态（服务端）

在服务端使用这两种状态 十分消耗服务器资源

![](D:\software_engineering\java\_java项目\SpringBoot+netty即时通信系统\Snipaste_2024-01-17_08-57-00.png)

在线状态功能设计

需求一 

+ 像qq一样 实时获取好友的在线状态，手动修改在线状态能够通知到好友

需求二

+ 打开搜索列表\群等能够获取到这一批人的在线状态



**优化**

+ 状态只推送给在线的用户

+ 采用按需拉拉取和临时订阅的方式

  + 我们如果在附近的人这样的场景需要展示某些用户的在线状态，先拉取一次这批用户的在线状态，然后再临时订阅这一批用户，当这批用户的在线状态发生改变时，通知给订阅了该用户的用户 

    > 通常情况下只需要在开始时拉取一次用户的在线状态即可 无需临时订阅



#### 十三章 im系统的拓展

让陌生人只能发送几条消息

业务性很强 不推荐添加在im系统当中去 可以在消息发送前后进行回调 判断这两个人是否已经关注，是否发送频率过高，



消息撤回功能的实现 不能由业务端实现 只能由im端去处理  具体实现就是 将原来的消息变更为"您已撤回一条消息"





拉取历史消息



视频通话实现流程与思路

srs实现流媒体服务器 [Docker | SRS (ossrs.net)](https://ossrs.net/lts/zh-cn/docs/v6/doc/getting-started)